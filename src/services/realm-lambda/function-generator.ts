import { FunctionDescriptor, FunctionVariable } from './types';

export const FUNCTION_TEMPLATE_MARKER = '// GENERATED BY RAPIDREALM'

export function generateFunctionSource(functionDescriptor: FunctionDescriptor): string {
  return `\
${FUNCTION_TEMPLATE_MARKER}
// DESCRIPTOR>>${JSON.stringify(functionDescriptor, undefined, '')}
exports = function(payload, response) {
    // Convert the webhook body from BSON to an EJSON object
    const $body = (payload.body && payload.body.text()) ? EJSON.parse(payload.body.text()) : {};

    // Query params, e.g. '?arg1=hello&arg2=world' => {arg1: "hello", arg2: "world"}
    const $query = {
        ...payload.query
    };

    ${functionDescriptor.variables.map(generateVariableStatement).join('\n')} 

    const $mdb = context.services.get(${JSON.stringify(functionDescriptor.dataSource)});
    const $collection = $mdb.db(${JSON.stringify(functionDescriptor.database)}).collection(${JSON.stringify(functionDescriptor.collection)})
    return $collection.${generateFunctionCall(functionDescriptor)};
};
`;
}

function generateVariableStatement(variable: FunctionVariable): string {
  let source = `let ${variable.name} = $body.${variable.name} === undefined ? $query.${variable.name} : $body.${variable.name};`;
  if (variable.default) {
    source += `\nif (${variable.name} === undefined) { ${variable.name} = ${JSON.stringify(variable.default)}; }`
  } else {
    source += `
if (${variable.name} === undefined) {
    // Respond with a malformed request error
    response.setStatusCode(400);
    response.setBody(\`Missing required argument: "${variable.name}"\`);
    return;
}
`;
  }

  switch (variable.type) {
    case 'number':
      source += `if (typeof ${variable.name} !== 'number') { ${variable.name} = parseInt('' + ${variable.name}, 10); }`;
      break;
    case 'boolean':
      source += `if (typeof ${variable.name} !== 'boolean') { ${variable.name} = ${variable.name} === 1 || ${variable.name} === 'true' || ${variable.name} === '1'; }`;
      break;
    default:
      break;
  }

  return source;
}

function generateFunctionCall(functionDescriptor: FunctionDescriptor): string {
  switch (functionDescriptor.type) {
    case 'query':
      return `find(${functionDescriptor.queryOrAggregation})`;
    case 'aggregation':
      return `aggregate(${functionDescriptor.queryOrAggregation})`;
    default:
      throw new Error(`Unsupported function descriptor type: ${(functionDescriptor as any).type}`)
  }
}
